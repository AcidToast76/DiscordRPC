'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events');

var _require = require('timers'),
    setTimeout = _require.setTimeout,
    clearTimeout = _require.clearTimeout;

var fetch = require('node-fetch');

var transports = require('./transports');

var _require2 = require('./constants'),
    RPCCommands = _require2.RPCCommands,
    RPCEvents = _require2.RPCEvents,
    RelationshipTypes = _require2.RelationshipTypes;

var _require3 = require('./util'),
    getPid = _require3.pid,
    uuid = _require3.uuid;

function subKey(event, args) {
  return "".concat(event).concat(JSON.stringify(args));
}
/**
 * @typedef {RPCClientOptions}
 * @extends {ClientOptions}
 * @prop {string} transport RPC transport. one of `ipc` or `websocket`
 */

/**
 * The main hub for interacting with Discord RPC
 * @extends {BaseClient}
 */


var RPCClient =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(RPCClient, _EventEmitter);

  /**
   * @param {RPCClientOptions} [options] Options for the client.
   * You must provide a transport
   */
  function RPCClient() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RPCClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RPCClient).call(this));
    _this.options = options;
    _this.accessToken = null;
    _this.clientId = null;
    /**
     * Application used in this client
     * @type {?ClientApplication}
     */

    _this.application = null;
    /**
     * User used in this application
     * @type {?User}
     */

    _this.user = null;
    var Transport = transports[options.transport];

    if (!Transport) {
      throw new TypeError('RPC_INVALID_TRANSPORT', options.transport);
    }

    _this.fetch = function (method, path) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          data = _ref.data,
          query = _ref.query;

      return fetch("".concat(_this.fetch.endpoint).concat(path).concat(query ? new URLSearchParams(query) : ''), {
        method: method,
        body: data,
        headers: {
          Authorization: "Bearer ".concat(_this.accessToken)
        }
      }).then(function _callee(r) {
        var body, e;
        return regeneratorRuntime.async(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return regeneratorRuntime.awrap(r.json());

              case 2:
                body = _context.sent;

                if (r.ok) {
                  _context.next = 7;
                  break;
                }

                e = new Error(r.status);
                e.body = body;
                throw e;

              case 7:
                return _context.abrupt("return", body);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        });
      });
    };

    _this.fetch.endpoint = 'https://discord.com/api';
    /**
     * Raw transport userd
     * @type {RPCTransport}
     * @private
     */

    _this.transport = new Transport(_assertThisInitialized(_this));

    _this.transport.on('message', _this._onRpcMessage.bind(_assertThisInitialized(_this)));
    /**
     * Map of nonces being expected from the transport
     * @type {Map}
     * @private
     */


    _this._expecting = new Map();
    _this._connectPromise = undefined;
    return _this;
  }
  /**
   * Search and connect to RPC
   */


  _createClass(RPCClient, [{
    key: "connect",
    value: function connect(clientId) {
      var _this2 = this;

      if (this._connectPromise) {
        return this._connectPromise;
      }

      this._connectPromise = new Promise(function (resolve, reject) {
        _this2.clientId = clientId;
        var timeout = setTimeout(function () {
          return reject(new Error('RPC_CONNECTION_TIMEOUT'));
        }, 20e3);
        timeout.unref();

        _this2.once('connected', function () {
          clearTimeout(timeout);
          resolve(_this2);
        });

        _this2.transport.once('close', function () {
          _this2._expecting.forEach(function (e) {
            e.reject(new Error('connection closed'));
          });

          _this2.emit('disconnected');

          reject(new Error('connection closed'));
        });

        _this2.transport.connect()["catch"](reject);
      });
      return this._connectPromise;
    }
    /**
     * @typedef {RPCLoginOptions}
     * @param {string} clientId Client ID
     * @param {string} [clientSecret] Client secret
     * @param {string} [accessToken] Access token
     * @param {string} [rpcToken] RPC token
     * @param {string} [tokenEndpoint] Token endpoint
     * @param {string[]} [scopes] Scopes to authorize with
     */

    /**
     * Performs authentication flow. Automatically calls Client#connect if needed.
     * @param {RPCLoginOptions} options Options for authentication.
     * At least one property must be provided to perform login.
     * @example client.login({ clientId: '1234567', clientSecret: 'abcdef123' });
     * @returns {Promise<RPCClient>}
     */

  }, {
    key: "login",
    value: function login() {
      var options,
          clientId,
          accessToken,
          _args2 = arguments;
      return regeneratorRuntime.async(function login$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              clientId = options.clientId, accessToken = options.accessToken;
              _context2.next = 4;
              return regeneratorRuntime.awrap(this.connect(clientId));

            case 4:
              if (options.scopes) {
                _context2.next = 7;
                break;
              }

              this.emit('ready');
              return _context2.abrupt("return", this);

            case 7:
              if (accessToken) {
                _context2.next = 11;
                break;
              }

              _context2.next = 10;
              return regeneratorRuntime.awrap(this.authorize(options));

            case 10:
              accessToken = _context2.sent;

            case 11:
              return _context2.abrupt("return", this.authenticate(accessToken));

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Request
     * @param {string} cmd Command
     * @param {Object} [args={}] Arguments
     * @param {string} [evt] Event
     * @returns {Promise}
     * @private
     */

  }, {
    key: "request",
    value: function request(cmd, args, evt) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var nonce = uuid();

        _this3.transport.send({
          cmd: cmd,
          args: args,
          evt: evt,
          nonce: nonce
        });

        _this3._expecting.set(nonce, {
          resolve: resolve,
          reject: reject
        });
      });
    }
    /**
     * Message handler
     * @param {Object} message message
     * @private
     */

  }, {
    key: "_onRpcMessage",
    value: function _onRpcMessage(message) {
      if (message.cmd === RPCCommands.DISPATCH && message.evt === RPCEvents.READY) {
        if (message.data.user) {
          this.user = message.data.user;
        }

        this.emit('connected');
      } else if (this._expecting.has(message.nonce)) {
        var _this$_expecting$get = this._expecting.get(message.nonce),
            resolve = _this$_expecting$get.resolve,
            reject = _this$_expecting$get.reject;

        if (message.evt === 'ERROR') {
          var e = new Error(message.data.message);
          e.code = message.data.code;
          e.data = message.data;
          reject(e);
        } else {
          resolve(message.data);
        }

        this._expecting["delete"](message.nonce);
      } else {
        this.emit(message.evt, message.data);
      }
    }
    /**
     * Authorize
     * @param {Object} options options
     * @returns {Promise}
     * @private
     */

  }, {
    key: "authorize",
    value: function authorize() {
      var _ref2,
          scopes,
          clientSecret,
          rpcToken,
          redirectUri,
          prompt,
          body,
          _ref3,
          code,
          response,
          _args3 = arguments;

      return regeneratorRuntime.async(function authorize$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _ref2 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, scopes = _ref2.scopes, clientSecret = _ref2.clientSecret, rpcToken = _ref2.rpcToken, redirectUri = _ref2.redirectUri, prompt = _ref2.prompt;

              if (!(clientSecret && rpcToken === true)) {
                _context3.next = 6;
                break;
              }

              _context3.next = 4;
              return regeneratorRuntime.awrap(this.fetch('POST', '/oauth2/token/rpc', {
                data: new URLSearchParams({
                  client_id: this.clientId,
                  client_secret: clientSecret
                })
              }));

            case 4:
              body = _context3.sent;
              rpcToken = body.rpc_token;

            case 6:
              _context3.next = 8;
              return regeneratorRuntime.awrap(this.request('AUTHORIZE', {
                scopes: scopes,
                client_id: this.clientId,
                prompt: prompt,
                rpc_token: rpcToken
              }));

            case 8:
              _ref3 = _context3.sent;
              code = _ref3.code;
              _context3.next = 12;
              return regeneratorRuntime.awrap(this.fetch('POST', '/oauth2/token', {
                data: new URLSearchParams({
                  client_id: this.clientId,
                  client_secret: clientSecret,
                  code: code,
                  grant_type: 'authorization_code',
                  redirect_uri: redirectUri
                })
              }));

            case 12:
              response = _context3.sent;
              return _context3.abrupt("return", response.access_token);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * Authenticate
     * @param {string} accessToken access token
     * @returns {Promise}
     * @private
     */

  }, {
    key: "authenticate",
    value: function authenticate(accessToken) {
      var _this4 = this;

      return this.request('AUTHENTICATE', {
        access_token: accessToken
      }).then(function (_ref4) {
        var application = _ref4.application,
            user = _ref4.user;
        _this4.accessToken = accessToken;
        _this4.application = application;
        _this4.user = user;

        _this4.emit('ready');

        return _this4;
      });
    }
    /**
     * Fetch a guild
     * @param {Snowflake} id Guild ID
     * @param {number} [timeout] Timeout request
     * @returns {Promise<Guild>}
     */

  }, {
    key: "getGuild",
    value: function getGuild(id, timeout) {
      return this.request(RPCCommands.GET_GUILD, {
        guild_id: id,
        timeout: timeout
      });
    }
    /**
     * Fetch all guilds
     * @param {number} [timeout] Timeout request
     * @returns {Promise<Collection<Snowflake, Guild>>}
     */

  }, {
    key: "getGuilds",
    value: function getGuilds(timeout) {
      return this.request(RPCCommands.GET_GUILDS, {
        timeout: timeout
      });
    }
    /**
     * Get a channel
     * @param {Snowflake} id Channel ID
     * @param {number} [timeout] Timeout request
     * @returns {Promise<Channel>}
     */

  }, {
    key: "getChannel",
    value: function getChannel(id, timeout) {
      return this.request(RPCCommands.GET_CHANNEL, {
        channel_id: id,
        timeout: timeout
      });
    }
    /**
     * Get all channels
     * @param {Snowflake} [id] Guild ID
     * @param {number} [timeout] Timeout request
     * @returns {Promise<Collection<Snowflake, Channel>>}
     */

  }, {
    key: "getChannels",
    value: function getChannels(id, timeout) {
      var _ref5, channels;

      return regeneratorRuntime.async(function getChannels$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return regeneratorRuntime.awrap(this.request(RPCCommands.GET_CHANNELS, {
                timeout: timeout,
                guild_id: id
              }));

            case 2:
              _ref5 = _context4.sent;
              channels = _ref5.channels;
              return _context4.abrupt("return", channels);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
    /**
     * @typedef {CertifiedDevice}
     * @prop {string} type One of `AUDIO_INPUT`, `AUDIO_OUTPUT`, `VIDEO_INPUT`
     * @prop {string} uuid This device's Windows UUID
     * @prop {object} vendor Vendor information
     * @prop {string} vendor.name Vendor's name
     * @prop {string} vendor.url Vendor's url
     * @prop {object} model Model information
     * @prop {string} model.name Model's name
     * @prop {string} model.url Model's url
     * @prop {string[]} related Array of related product's Windows UUIDs
     * @prop {boolean} echoCancellation If the device has echo cancellation
     * @prop {boolean} noiseSuppression If the device has noise suppression
     * @prop {boolean} automaticGainControl If the device has automatic gain control
     * @prop {boolean} hardwareMute If the device has a hardware mute
     */

    /**
     * Tell discord which devices are certified
     * @param {CertifiedDevice[]} devices Certified devices to send to discord
     * @returns {Promise}
     */

  }, {
    key: "setCertifiedDevices",
    value: function setCertifiedDevices(devices) {
      return this.request(RPCCommands.SET_CERTIFIED_DEVICES, {
        devices: devices.map(function (d) {
          return {
            type: d.type,
            id: d.uuid,
            vendor: d.vendor,
            model: d.model,
            related: d.related,
            echo_cancellation: d.echoCancellation,
            noise_suppression: d.noiseSuppression,
            automatic_gain_control: d.automaticGainControl,
            hardware_mute: d.hardwareMute
          };
        })
      });
    }
    /**
     * @typedef {UserVoiceSettings}
     * @prop {Snowflake} id ID of the user these settings apply to
     * @prop {?Object} [pan] Pan settings, an object with `left` and `right` set between
     * 0.0 and 1.0, inclusive
     * @prop {?number} [volume=100] The volume
     * @prop {bool} [mute] If the user is muted
     */

    /**
     * Set the voice settings for a user, by id
     * @param {Snowflake} id ID of the user to set
     * @param {UserVoiceSettings} settings Settings
     * @returns {Promise}
     */

  }, {
    key: "setUserVoiceSettings",
    value: function setUserVoiceSettings(id, settings) {
      return this.request(RPCCommands.SET_USER_VOICE_SETTINGS, {
        user_id: id,
        pan: settings.pan,
        mute: settings.mute,
        volume: settings.volume
      });
    }
    /**
     * Move the user to a voice channel
     * @param {Snowflake} id ID of the voice channel
     * @param {Object} [options] Options
     * @param {number} [options.timeout] Timeout for the command
     * @param {boolean} [options.force] Force this move. This should only be done if you
     * have explicit permission from the user.
     * @returns {Promise}
     */

  }, {
    key: "selectVoiceChannel",
    value: function selectVoiceChannel(id) {
      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          timeout = _ref6.timeout,
          _ref6$force = _ref6.force,
          force = _ref6$force === void 0 ? false : _ref6$force;

      return this.request(RPCCommands.SELECT_VOICE_CHANNEL, {
        channel_id: id,
        timeout: timeout,
        force: force
      });
    }
    /**
     * Move the user to a text channel
     * @param {Snowflake} id ID of the voice channel
     * @param {Object} [options] Options
     * @param {number} [options.timeout] Timeout for the command
     * have explicit permission from the user.
     * @returns {Promise}
     */

  }, {
    key: "selectTextChannel",
    value: function selectTextChannel(id) {
      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          timeout = _ref7.timeout;

      return this.request(RPCCommands.SELECT_TEXT_CHANNEL, {
        channel_id: id,
        timeout: timeout
      });
    }
    /**
     * Get current voice settings
     * @returns {Promise}
     */

  }, {
    key: "getVoiceSettings",
    value: function getVoiceSettings() {
      return this.request(RPCCommands.GET_VOICE_SETTINGS).then(function (s) {
        return {
          automaticGainControl: s.automatic_gain_control,
          echoCancellation: s.echo_cancellation,
          noiseSuppression: s.noise_suppression,
          qos: s.qos,
          silenceWarning: s.silence_warning,
          deaf: s.deaf,
          mute: s.mute,
          input: {
            availableDevices: s.input.available_devices,
            device: s.input.device_id,
            volume: s.input.volume
          },
          output: {
            availableDevices: s.output.available_devices,
            device: s.output.device_id,
            volume: s.output.volume
          },
          mode: {
            type: s.mode.type,
            autoThreshold: s.mode.auto_threshold,
            threshold: s.mode.threshold,
            shortcut: s.mode.shortcut,
            delay: s.mode.delay
          }
        };
      });
    }
    /**
     * Set current voice settings, overriding the current settings until this session disconnects.
     * This also locks the settings for any other rpc sessions which may be connected.
     * @param {Object} args Settings
     * @returns {Promise}
     */

  }, {
    key: "setVoiceSettings",
    value: function setVoiceSettings(args) {
      return this.request(RPCCommands.SET_VOICE_SETTINGS, {
        automatic_gain_control: args.automaticGainControl,
        echo_cancellation: args.echoCancellation,
        noise_suppression: args.noiseSuppression,
        qos: args.qos,
        silence_warning: args.silenceWarning,
        deaf: args.deaf,
        mute: args.mute,
        input: args.input ? {
          device_id: args.input.device,
          volume: args.input.volume
        } : undefined,
        output: args.output ? {
          device_id: args.output.device,
          volume: args.output.volume
        } : undefined,
        mode: args.mode ? {
          type: args.mode.type,
          auto_threshold: args.mode.autoThreshold,
          threshold: args.mode.threshold,
          shortcut: args.mode.shortcut,
          delay: args.mode.delay
        } : undefined
      });
    }
    /**
     * Capture a shortcut using the client
     * The callback takes (key, stop) where `stop` is a function that will stop capturing.
     * This `stop` function must be called before disconnecting or else the user will have
     * to restart their client.
     * @param {Function} callback Callback handling keys
     * @returns {Promise<Function>}
     */

  }, {
    key: "captureShortcut",
    value: function captureShortcut(callback) {
      var _this5 = this;

      var subid = subKey(RPCEvents.CAPTURE_SHORTCUT_CHANGE);

      var stop = function stop() {
        _this5._subscriptions["delete"](subid);

        return _this5.request(RPCCommands.CAPTURE_SHORTCUT, {
          action: 'STOP'
        });
      };

      this._subscriptions.set(subid, function (_ref8) {
        var shortcut = _ref8.shortcut;
        callback(shortcut, stop);
      });

      return this.request(RPCCommands.CAPTURE_SHORTCUT, {
        action: 'START'
      }).then(function () {
        return stop;
      });
    }
    /**
     * Sets the presence for the logged in user.
     * @param {object} args The rich presence to pass.
     * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.
     * @returns {Promise}
     */

  }, {
    key: "setActivity",
    value: function setActivity() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var pid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getPid();
      var timestamps;
      var assets;
      var party;
      var secrets;

      if (args.startTimestamp || args.endTimestamp) {
        timestamps = {
          start: args.startTimestamp,
          end: args.endTimestamp
        };

        if (timestamps.start instanceof Date) {
          timestamps.start = Math.round(timestamps.start.getTime());
        }

        if (timestamps.end instanceof Date) {
          timestamps.end = Math.round(timestamps.end.getTime());
        }

        if (timestamps.start > 2147483647000) {
          throw new RangeError('timestamps.start must fit into a unix timestamp');
        }

        if (timestamps.end > 2147483647000) {
          throw new RangeError('timestamps.end must fit into a unix timestamp');
        }
      }

      if (args.largeImageKey || args.largeImageText || args.smallImageKey || args.smallImageText) {
        assets = {
          large_image: args.largeImageKey,
          large_text: args.largeImageText,
          small_image: args.smallImageKey,
          small_text: args.smallImageText
        };
      }

      if (args.partySize || args.partyId || args.partyMax) {
        party = {
          id: args.partyId
        };

        if (args.partySize || args.partyMax) {
          party.size = [args.partySize, args.partyMax];
        }
      }

      if (args.matchSecret || args.joinSecret || args.spectateSecret) {
        secrets = {
          match: args.matchSecret,
          join: args.joinSecret,
          spectate: args.spectateSecret
        };
      }

      return this.request(RPCCommands.SET_ACTIVITY, {
        pid: pid,
        activity: {
          state: args.state,
          details: args.details,
          timestamps: timestamps,
          assets: assets,
          party: party,
          secrets: secrets,
          buttons: args.buttons,
          instance: !!args.instance
        }
      });
    }
    /**
     * Clears the currently set presence, if any. This will hide the "Playing X" message
     * displayed below the user's name.
     * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.
     * @returns {Promise}
     */

  }, {
    key: "clearActivity",
    value: function clearActivity() {
      var pid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getPid();
      return this.request(RPCCommands.SET_ACTIVITY, {
        pid: pid
      });
    }
    /**
     * Invite a user to join the game the RPC user is currently playing
     * @param {User} user The user to invite
     * @returns {Promise}
     */

  }, {
    key: "sendJoinInvite",
    value: function sendJoinInvite(user) {
      return this.request(RPCCommands.SEND_ACTIVITY_JOIN_INVITE, {
        user_id: user.id || user
      });
    }
    /**
     * Request to join the game the user is playing
     * @param {User} user The user whose game you want to request to join
     * @returns {Promise}
     */

  }, {
    key: "sendJoinRequest",
    value: function sendJoinRequest(user) {
      return this.request(RPCCommands.SEND_ACTIVITY_JOIN_REQUEST, {
        user_id: user.id || user
      });
    }
    /**
     * Reject a join request from a user
     * @param {User} user The user whose request you wish to reject
     * @returns {Promise}
     */

  }, {
    key: "closeJoinRequest",
    value: function closeJoinRequest(user) {
      return this.request(RPCCommands.CLOSE_ACTIVITY_JOIN_REQUEST, {
        user_id: user.id || user
      });
    }
  }, {
    key: "createLobby",
    value: function createLobby(type, capacity, metadata) {
      return this.request(RPCCommands.CREATE_LOBBY, {
        type: type,
        capacity: capacity,
        metadata: metadata
      });
    }
  }, {
    key: "updateLobby",
    value: function updateLobby(lobby) {
      var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          type = _ref9.type,
          owner = _ref9.owner,
          capacity = _ref9.capacity,
          metadata = _ref9.metadata;

      return this.request(RPCCommands.UPDATE_LOBBY, {
        id: lobby.id || lobby,
        type: type,
        owner_id: owner && owner.id || owner,
        capacity: capacity,
        metadata: metadata
      });
    }
  }, {
    key: "deleteLobby",
    value: function deleteLobby(lobby) {
      return this.request(RPCCommands.DELETE_LOBBY, {
        id: lobby.id || lobby
      });
    }
  }, {
    key: "connectToLobby",
    value: function connectToLobby(id, secret) {
      return this.request(RPCCommands.CONNECT_TO_LOBBY, {
        id: id,
        secret: secret
      });
    }
  }, {
    key: "sendToLobby",
    value: function sendToLobby(lobby, data) {
      return this.request(RPCCommands.SEND_TO_LOBBY, {
        id: lobby.id || lobby,
        data: data
      });
    }
  }, {
    key: "disconnectFromLobby",
    value: function disconnectFromLobby(lobby) {
      return this.request(RPCCommands.DISCONNECT_FROM_LOBBY, {
        id: lobby.id || lobby
      });
    }
  }, {
    key: "updateLobbyMember",
    value: function updateLobbyMember(lobby, user, metadata) {
      return this.request(RPCCommands.UPDATE_LOBBY_MEMBER, {
        lobby_id: lobby.id || lobby,
        user_id: user.id || user,
        metadata: metadata
      });
    }
  }, {
    key: "getRelationships",
    value: function getRelationships() {
      var types = Object.keys(RelationshipTypes);
      return this.request(RPCCommands.GET_RELATIONSHIPS).then(function (o) {
        return o.relationships.map(function (r) {
          return _objectSpread({}, r, {
            type: types[r.type]
          });
        });
      });
    }
    /**
     * Subscribe to an event
     * @param {string} event Name of event e.g. `MESSAGE_CREATE`
     * @param {Object} [args] Args for event e.g. `{ channel_id: '1234' }`
     * @returns {Promise<Object>}
     */

  }, {
    key: "subscribe",
    value: function subscribe(event, args) {
      var _this6 = this;

      return regeneratorRuntime.async(function subscribe$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(this.request(RPCCommands.SUBSCRIBE, args, event));

            case 2:
              return _context5.abrupt("return", {
                unsubscribe: function unsubscribe() {
                  return _this6.request(RPCCommands.UNSUBSCRIBE, args, event);
                }
              });

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
    /**
     * Destroy the client
     */

  }, {
    key: "destroy",
    value: function destroy() {
      return regeneratorRuntime.async(function destroy$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return regeneratorRuntime.awrap(this.transport.close());

            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }]);

  return RPCClient;
}(EventEmitter);

module.exports = RPCClient;
//# sourceMappingURL=client.dev.js.map
