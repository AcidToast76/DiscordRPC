{"version":3,"sources":["client.js"],"names":["EventEmitter","require","setTimeout","clearTimeout","fetch","transports","RPCCommands","RPCEvents","RelationshipTypes","getPid","pid","uuid","subKey","event","args","concat","JSON","stringify","RPCClient","_this","options","arguments","length","undefined","_classCallCheck","this","accessToken","application","user","Transport","transport","TypeError","method","path","_ref","data","query","endpoint","URLSearchParams","body","headers","Authorization","r","e","regeneratorRuntime","async","_context","prev","next","awrap","json","sent","ok","Error","status","abrupt","stop","_onRpcMessage","bind","_assertThisInitialized","_expecting","Map","_connectPromise","clientId","_this2","Promise","resolve","reject","timeout","unref","once","forEach","emit","connect","scopes","authorize","authenticate","cmd","evt","_this3","nonce","send","set","message","DISPATCH","READY","_this$_expecting$get","get","code","clientSecret","rpcToken","redirectUri","prompt","client_id","client_secret","rpc_token","request","grant_type","redirect_uri","response","access_token","then","_ref4","_this4","id","GET_GUILD","guild_id","GET_GUILDS","GET_CHANNEL","channel_id","GET_CHANNELS","channels","devices","SET_CERTIFIED_DEVICES","map","d","type","vendor","model","related","echo_cancellation","echoCancellation","noise_suppression","settings","SET_USER_VOICE_SETTINGS","user_id","pan","mute","volume","_ref6","_ref6$force","force","SELECT_TEXT_CHANNEL","GET_VOICE_SETTINGS","s","automatic_gain_control","noiseSuppression","qos","silenceWarning","silence_warning","deaf","input","availableDevices","available_devices","output","mode","auto_threshold","threshold","shortcut","delay","SET_VOICE_SETTINGS","automaticGainControl","device_id","device","autoThreshold","callback","_this5","_subscriptions","subid","CAPTURE_SHORTCUT","action","CAPTURE_SHORTCUT_CHANGE","_ref8","timestamps","assets","party","secrets","startTimestamp","start","Date","Math","round","getTime","end","RangeError","largeImageKey","largeImageText","smallImageKey","smallImageText","large_image","small_text","partySize","partyId","partyMax","size","matchSecret","joinSecret","spectateSecret","match","join","spectate","SET_ACTIVITY","activity","state","details","buttons","instance","hardware_mute","SEND_ACTIVITY_JOIN_REQUEST","CLOSE_ACTIVITY_JOIN_REQUEST","metadata","CREATE_LOBBY","capacity","lobby","_ref9","owner","UPDATE_LOBBY","owner_id","DELETE_LOBBY","CONNECT_TO_LOBBY","secret","SEND_TO_LOBBY","DISCONNECT_FROM_LOBBY","UPDATE_LOBBY_MEMBER","types","Object","keys","GET_RELATIONSHIPS","o","relationships","_objectSpread","unsubscribe","_this6","UNSUBSCRIBE","close","module","exports"],"mappings":"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","file":"client.min.js","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst { setTimeout, clearTimeout } = require('timers');\nconst fetch = require('node-fetch');\nconst transports = require('./transports');\nconst { RPCCommands, RPCEvents, RelationshipTypes } = require('./constants');\nconst { pid: getPid, uuid } = require('./util');\n\nfunction subKey(event, args) {\n  return `${event}${JSON.stringify(args)}`;\n}\n\n/**\n * @typedef {RPCClientOptions}\n * @extends {ClientOptions}\n * @prop {string} transport RPC transport. one of `ipc` or `websocket`\n */\n\n/**\n * The main hub for interacting with Discord RPC\n * @extends {BaseClient}\n */\nclass RPCClient extends EventEmitter {\n  /**\n   * @param {RPCClientOptions} [options] Options for the client.\n   * You must provide a transport\n   */\n  constructor(options = {}) {\n    super();\n\n    this.options = options;\n\n    this.accessToken = null;\n    this.clientId = null;\n\n    /**\n     * Application used in this client\n     * @type {?ClientApplication}\n     */\n    this.application = null;\n\n    /**\n     * User used in this application\n     * @type {?User}\n     */\n    this.user = null;\n\n    const Transport = transports[options.transport];\n    if (!Transport) {\n      throw new TypeError('RPC_INVALID_TRANSPORT', options.transport);\n    }\n\n    this.fetch = (method, path, { data, query } = {}) =>\n      fetch(`${this.fetch.endpoint}${path}${query ? new URLSearchParams(query) : ''}`, {\n        method,\n        body: data,\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n        },\n      }).then(async (r) => {\n        const body = await r.json();\n        if (!r.ok) {\n          const e = new Error(r.status);\n          e.body = body;\n          throw e;\n        }\n        return body;\n      });\n\n    this.fetch.endpoint = 'https://discord.com/api';\n\n    /**\n     * Raw transport userd\n     * @type {RPCTransport}\n     * @private\n     */\n    this.transport = new Transport(this);\n    this.transport.on('message', this._onRpcMessage.bind(this));\n\n    /**\n     * Map of nonces being expected from the transport\n     * @type {Map}\n     * @private\n     */\n    this._expecting = new Map();\n\n    this._connectPromise = undefined;\n  }\n\n  /**\n   * Search and connect to RPC\n   */\n  connect(clientId) {\n    if (this._connectPromise) {\n      return this._connectPromise;\n    }\n    this._connectPromise = new Promise((resolve, reject) => {\n      this.clientId = clientId;\n      const timeout = setTimeout(() => reject(new Error('RPC_CONNECTION_TIMEOUT')), 20e3);\n      timeout.unref();\n      this.once('connected', () => {\n        clearTimeout(timeout);\n        resolve(this);\n      });\n      this.transport.once('close', () => {\n        this._expecting.forEach((e) => {\n          e.reject(new Error('connection closed'));\n        });\n        this.emit('disconnected');\n        reject(new Error('connection closed'));\n      });\n      this.transport.connect().catch(reject);\n    });\n    return this._connectPromise;\n  }\n\n  /**\n   * @typedef {RPCLoginOptions}\n   * @param {string} clientId Client ID\n   * @param {string} [clientSecret] Client secret\n   * @param {string} [accessToken] Access token\n   * @param {string} [rpcToken] RPC token\n   * @param {string} [tokenEndpoint] Token endpoint\n   * @param {string[]} [scopes] Scopes to authorize with\n   */\n\n  /**\n   * Performs authentication flow. Automatically calls Client#connect if needed.\n   * @param {RPCLoginOptions} options Options for authentication.\n   * At least one property must be provided to perform login.\n   * @example client.login({ clientId: '1234567', clientSecret: 'abcdef123' });\n   * @returns {Promise<RPCClient>}\n   */\n  async login(options = {}) {\n    let { clientId, accessToken } = options;\n    await this.connect(clientId);\n    if (!options.scopes) {\n      this.emit('ready');\n      return this;\n    }\n    if (!accessToken) {\n      accessToken = await this.authorize(options);\n    }\n    return this.authenticate(accessToken);\n  }\n\n  /**\n   * Request\n   * @param {string} cmd Command\n   * @param {Object} [args={}] Arguments\n   * @param {string} [evt] Event\n   * @returns {Promise}\n   * @private\n   */\n  request(cmd, args, evt) {\n    return new Promise((resolve, reject) => {\n      const nonce = uuid();\n      this.transport.send({ cmd, args, evt, nonce });\n      this._expecting.set(nonce, { resolve, reject });\n    });\n  }\n\n  /**\n   * Message handler\n   * @param {Object} message message\n   * @private\n   */\n  _onRpcMessage(message) {\n    if (message.cmd === RPCCommands.DISPATCH && message.evt === RPCEvents.READY) {\n      if (message.data.user) {\n        this.user = message.data.user;\n      }\n      this.emit('connected');\n    } else if (this._expecting.has(message.nonce)) {\n      const { resolve, reject } = this._expecting.get(message.nonce);\n      if (message.evt === 'ERROR') {\n        const e = new Error(message.data.message);\n        e.code = message.data.code;\n        e.data = message.data;\n        reject(e);\n      } else {\n        resolve(message.data);\n      }\n      this._expecting.delete(message.nonce);\n    } else {\n      this.emit(message.evt, message.data);\n    }\n  }\n\n  /**\n   * Authorize\n   * @param {Object} options options\n   * @returns {Promise}\n   * @private\n   */\n  async authorize({ scopes, clientSecret, rpcToken, redirectUri, prompt } = {}) {\n    if (clientSecret && rpcToken === true) {\n      const body = await this.fetch('POST', '/oauth2/token/rpc', {\n        data: new URLSearchParams({\n          client_id: this.clientId,\n          client_secret: clientSecret,\n        }),\n      });\n      rpcToken = body.rpc_token;\n    }\n\n    const { code } = await this.request('AUTHORIZE', {\n      scopes,\n      client_id: this.clientId,\n      prompt,\n      rpc_token: rpcToken,\n    });\n\n    const response = await this.fetch('POST', '/oauth2/token', {\n      data: new URLSearchParams({\n        client_id: this.clientId,\n        client_secret: clientSecret,\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: redirectUri,\n      }),\n    });\n\n    return response.access_token;\n  }\n\n  /**\n   * Authenticate\n   * @param {string} accessToken access token\n   * @returns {Promise}\n   * @private\n   */\n  authenticate(accessToken) {\n    return this.request('AUTHENTICATE', { access_token: accessToken })\n      .then(({ application, user }) => {\n        this.accessToken = accessToken;\n        this.application = application;\n        this.user = user;\n        this.emit('ready');\n        return this;\n      });\n  }\n\n\n  /**\n   * Fetch a guild\n   * @param {Snowflake} id Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Guild>}\n   */\n  getGuild(id, timeout) {\n    return this.request(RPCCommands.GET_GUILD, { guild_id: id, timeout });\n  }\n\n  /**\n   * Fetch all guilds\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Guild>>}\n   */\n  getGuilds(timeout) {\n    return this.request(RPCCommands.GET_GUILDS, { timeout });\n  }\n\n  /**\n   * Get a channel\n   * @param {Snowflake} id Channel ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Channel>}\n   */\n  getChannel(id, timeout) {\n    return this.request(RPCCommands.GET_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get all channels\n   * @param {Snowflake} [id] Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Channel>>}\n   */\n  async getChannels(id, timeout) {\n    const { channels } = await this.request(RPCCommands.GET_CHANNELS, {\n      timeout,\n      guild_id: id,\n    });\n    return channels;\n  }\n\n  /**\n   * @typedef {CertifiedDevice}\n   * @prop {string} type One of `AUDIO_INPUT`, `AUDIO_OUTPUT`, `VIDEO_INPUT`\n   * @prop {string} uuid This device's Windows UUID\n   * @prop {object} vendor Vendor information\n   * @prop {string} vendor.name Vendor's name\n   * @prop {string} vendor.url Vendor's url\n   * @prop {object} model Model information\n   * @prop {string} model.name Model's name\n   * @prop {string} model.url Model's url\n   * @prop {string[]} related Array of related product's Windows UUIDs\n   * @prop {boolean} echoCancellation If the device has echo cancellation\n   * @prop {boolean} noiseSuppression If the device has noise suppression\n   * @prop {boolean} automaticGainControl If the device has automatic gain control\n   * @prop {boolean} hardwareMute If the device has a hardware mute\n   */\n\n  /**\n   * Tell discord which devices are certified\n   * @param {CertifiedDevice[]} devices Certified devices to send to discord\n   * @returns {Promise}\n   */\n  setCertifiedDevices(devices) {\n    return this.request(RPCCommands.SET_CERTIFIED_DEVICES, {\n      devices: devices.map((d) => ({\n        type: d.type,\n        id: d.uuid,\n        vendor: d.vendor,\n        model: d.model,\n        related: d.related,\n        echo_cancellation: d.echoCancellation,\n        noise_suppression: d.noiseSuppression,\n        automatic_gain_control: d.automaticGainControl,\n        hardware_mute: d.hardwareMute,\n      })),\n    });\n  }\n\n  /**\n   * @typedef {UserVoiceSettings}\n   * @prop {Snowflake} id ID of the user these settings apply to\n   * @prop {?Object} [pan] Pan settings, an object with `left` and `right` set between\n   * 0.0 and 1.0, inclusive\n   * @prop {?number} [volume=100] The volume\n   * @prop {bool} [mute] If the user is muted\n   */\n\n  /**\n   * Set the voice settings for a user, by id\n   * @param {Snowflake} id ID of the user to set\n   * @param {UserVoiceSettings} settings Settings\n   * @returns {Promise}\n   */\n  setUserVoiceSettings(id, settings) {\n    return this.request(RPCCommands.SET_USER_VOICE_SETTINGS, {\n      user_id: id,\n      pan: settings.pan,\n      mute: settings.mute,\n      volume: settings.volume,\n    });\n  }\n\n  /**\n   * Move the user to a voice channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * @param {boolean} [options.force] Force this move. This should only be done if you\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectVoiceChannel(id, { timeout, force = false } = {}) {\n    return this.request(RPCCommands.SELECT_VOICE_CHANNEL, { channel_id: id, timeout, force });\n  }\n\n  /**\n   * Move the user to a text channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectTextChannel(id, { timeout } = {}) {\n    return this.request(RPCCommands.SELECT_TEXT_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get current voice settings\n   * @returns {Promise}\n   */\n  getVoiceSettings() {\n    return this.request(RPCCommands.GET_VOICE_SETTINGS)\n      .then((s) => ({\n        automaticGainControl: s.automatic_gain_control,\n        echoCancellation: s.echo_cancellation,\n        noiseSuppression: s.noise_suppression,\n        qos: s.qos,\n        silenceWarning: s.silence_warning,\n        deaf: s.deaf,\n        mute: s.mute,\n        input: {\n          availableDevices: s.input.available_devices,\n          device: s.input.device_id,\n          volume: s.input.volume,\n        },\n        output: {\n          availableDevices: s.output.available_devices,\n          device: s.output.device_id,\n          volume: s.output.volume,\n        },\n        mode: {\n          type: s.mode.type,\n          autoThreshold: s.mode.auto_threshold,\n          threshold: s.mode.threshold,\n          shortcut: s.mode.shortcut,\n          delay: s.mode.delay,\n        },\n      }));\n  }\n\n  /**\n   * Set current voice settings, overriding the current settings until this session disconnects.\n   * This also locks the settings for any other rpc sessions which may be connected.\n   * @param {Object} args Settings\n   * @returns {Promise}\n   */\n  setVoiceSettings(args) {\n    return this.request(RPCCommands.SET_VOICE_SETTINGS, {\n      automatic_gain_control: args.automaticGainControl,\n      echo_cancellation: args.echoCancellation,\n      noise_suppression: args.noiseSuppression,\n      qos: args.qos,\n      silence_warning: args.silenceWarning,\n      deaf: args.deaf,\n      mute: args.mute,\n      input: args.input ? {\n        device_id: args.input.device,\n        volume: args.input.volume,\n      } : undefined,\n      output: args.output ? {\n        device_id: args.output.device,\n        volume: args.output.volume,\n      } : undefined,\n      mode: args.mode ? {\n        type: args.mode.type,\n        auto_threshold: args.mode.autoThreshold,\n        threshold: args.mode.threshold,\n        shortcut: args.mode.shortcut,\n        delay: args.mode.delay,\n      } : undefined,\n    });\n  }\n\n  /**\n   * Capture a shortcut using the client\n   * The callback takes (key, stop) where `stop` is a function that will stop capturing.\n   * This `stop` function must be called before disconnecting or else the user will have\n   * to restart their client.\n   * @param {Function} callback Callback handling keys\n   * @returns {Promise<Function>}\n   */\n  captureShortcut(callback) {\n    const subid = subKey(RPCEvents.CAPTURE_SHORTCUT_CHANGE);\n    const stop = () => {\n      this._subscriptions.delete(subid);\n      return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'STOP' });\n    };\n    this._subscriptions.set(subid, ({ shortcut }) => {\n      callback(shortcut, stop);\n    });\n    return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'START' })\n      .then(() => stop);\n  }\n\n  /**\n   * Sets the presence for the logged in user.\n   * @param {object} args The rich presence to pass.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  setActivity(args = {}, pid = getPid()) {\n    let timestamps;\n    let assets;\n    let party;\n    let secrets;\n    if (args.startTimestamp || args.endTimestamp) {\n      timestamps = {\n        start: args.startTimestamp,\n        end: args.endTimestamp,\n      };\n      if (timestamps.start instanceof Date) {\n        timestamps.start = Math.round(timestamps.start.getTime());\n      }\n      if (timestamps.end instanceof Date) {\n        timestamps.end = Math.round(timestamps.end.getTime());\n      }\n      if (timestamps.start > 2147483647000) {\n        throw new RangeError('timestamps.start must fit into a unix timestamp');\n      }\n      if (timestamps.end > 2147483647000) {\n        throw new RangeError('timestamps.end must fit into a unix timestamp');\n      }\n    }\n    if (\n      args.largeImageKey || args.largeImageText\n      || args.smallImageKey || args.smallImageText\n    ) {\n      assets = {\n        large_image: args.largeImageKey,\n        large_text: args.largeImageText,\n        small_image: args.smallImageKey,\n        small_text: args.smallImageText,\n      };\n    }\n    if (args.partySize || args.partyId || args.partyMax) {\n      party = { id: args.partyId };\n      if (args.partySize || args.partyMax) {\n        party.size = [args.partySize, args.partyMax];\n      }\n    }\n    if (args.matchSecret || args.joinSecret || args.spectateSecret) {\n      secrets = {\n        match: args.matchSecret,\n        join: args.joinSecret,\n        spectate: args.spectateSecret,\n      };\n    }\n\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n      activity: {\n        state: args.state,\n        details: args.details,\n        timestamps,\n        assets,\n        party,\n        secrets,\n        buttons: args.buttons,\n        instance: !!args.instance,\n      },\n    });\n  }\n\n  /**\n   * Clears the currently set presence, if any. This will hide the \"Playing X\" message\n   * displayed below the user's name.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  clearActivity(pid = getPid()) {\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n    });\n  }\n\n  /**\n   * Invite a user to join the game the RPC user is currently playing\n   * @param {User} user The user to invite\n   * @returns {Promise}\n   */\n  sendJoinInvite(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_INVITE, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Request to join the game the user is playing\n   * @param {User} user The user whose game you want to request to join\n   * @returns {Promise}\n   */\n  sendJoinRequest(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Reject a join request from a user\n   * @param {User} user The user whose request you wish to reject\n   * @returns {Promise}\n   */\n  closeJoinRequest(user) {\n    return this.request(RPCCommands.CLOSE_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  createLobby(type, capacity, metadata) {\n    return this.request(RPCCommands.CREATE_LOBBY, {\n      type,\n      capacity,\n      metadata,\n    });\n  }\n\n  updateLobby(lobby, { type, owner, capacity, metadata } = {}) {\n    return this.request(RPCCommands.UPDATE_LOBBY, {\n      id: lobby.id || lobby,\n      type,\n      owner_id: (owner && owner.id) || owner,\n      capacity,\n      metadata,\n    });\n  }\n\n  deleteLobby(lobby) {\n    return this.request(RPCCommands.DELETE_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  connectToLobby(id, secret) {\n    return this.request(RPCCommands.CONNECT_TO_LOBBY, {\n      id,\n      secret,\n    });\n  }\n\n  sendToLobby(lobby, data) {\n    return this.request(RPCCommands.SEND_TO_LOBBY, {\n      id: lobby.id || lobby,\n      data,\n    });\n  }\n\n  disconnectFromLobby(lobby) {\n    return this.request(RPCCommands.DISCONNECT_FROM_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  updateLobbyMember(lobby, user, metadata) {\n    return this.request(RPCCommands.UPDATE_LOBBY_MEMBER, {\n      lobby_id: lobby.id || lobby,\n      user_id: user.id || user,\n      metadata,\n    });\n  }\n\n  getRelationships() {\n    const types = Object.keys(RelationshipTypes);\n    return this.request(RPCCommands.GET_RELATIONSHIPS)\n      .then((o) => o.relationships.map((r) => ({\n        ...r,\n        type: types[r.type],\n      })));\n  }\n\n  /**\n   * Subscribe to an event\n   * @param {string} event Name of event e.g. `MESSAGE_CREATE`\n   * @param {Object} [args] Args for event e.g. `{ channel_id: '1234' }`\n   * @returns {Promise<Object>}\n   */\n  async subscribe(event, args) {\n    await this.request(RPCCommands.SUBSCRIBE, args, event);\n    return {\n      unsubscribe: () => this.request(RPCCommands.UNSUBSCRIBE, args, event),\n    };\n  }\n\n  /**\n   * Destroy the client\n   */\n  async destroy() {\n    await this.transport.close();\n  }\n}\n\nmodule.exports = RPCClient;\n"]}